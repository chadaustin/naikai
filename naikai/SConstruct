from SCons.Builder import Builder
from os import path
import os
import sys


### LOAD BUILD CONFIGURATION ###

try:
    BUILD_RC = os.environ['NAIKAI_BUILD_CFG']
except:
    BUILD_RC = path.join(os.environ['HOME'], 'naikai_build')

try:
    execfile(BUILD_RC)
except:
    print "Can't open build configuration file!"
    print "Set NAIKAI_BUILD_CFG or put a configuration file in"
    print "$HOME/naikai_build."
    sys.exit()

# make sure we have all of the necessary variables
try:
    NK_MOZ_DIST
    NK_MOZ_DIST_BIN
except:
    print "NK_MOZ_DIST or NK_MOZ_DIST_BIN were not set!  You must set them"
    print "in the build configuration file!"
    sys.exit()


### BUILD VARIABLES ###

# build/dist directory
BUILD = 'build'
MODULES = [ 'base', 'nrun', 'test', 'windowing' ]


XPIDL_COMMAND = 'xpidl -I ' + path.join(NK_MOZ_DIST, 'idl') + ' $IDL_INCLUDE'

# set default target
Default(BUILD)

MOZ_INCLUDE = reduce(
  lambda a, b: a + '-I ' + path.join(NK_MOZ_DIST, 'include', b) + ' ',
  ['xpcom', 'nspr', 'string'], '')


### BUILDERS ###

Builders = [
    Builder(
        name = 'TypeLibrary',
        action = XPIDL_COMMAND + ' -m typelib -e $TARGET $SOURCES'),
    Builder(
        name = 'InterfaceHeader',
        action = XPIDL_COMMAND + ' -m header -e $TARGET $SOURCES'),
    Builder(
        name = 'Object',
        action = 'CL /nologo /c /DXP_WIN /DXP_WIN32 /MT /O2 ' + MOZ_INCLUDE +
                 ' $INCLUDE /Fo$TARGET $SOURCES'),
    Builder(
	name = 'Program',
        action = 'LINK /nologo /LIBPATH:$LIBPATH ' +
                 '/out:$TARGET $SOURCES $LIBRARIES'),
    Builder(
	name = 'Component',
	action = 'LINK /nologo /LIBPATH:$LIBPATH /DLL ' +
                 '/out:$TARGET $SOURCES $LIBRARIES'),
]


### SCANNERS ###

#class IDLScanner(SCons.Scanner.Recursive):
#Scanners = [
#    Scons.Scanner.C.CScan(),
#    IDLScanner(SCons.Scanner.Recursive)
#	),
#]


# create an environment
env = Environment(
    ENV = os.environ,
    BUILDERS = Builders,
#    SCANNERS = Scanners,
    LIBPATH = path.join(NK_MOZ_DIST_BIN, 'lib'))

# process each module
for m in MODULES:
    try:
	# defaults
	REQUIRES   = []
	IDL_FILES  = []
	PROGRAMS   = []
	COMPONENTS = []

	execfile(path.join(m, 'module.py'), locals())

      	# all modules 'require' themselves
	idl_include = ''
        include = ''
	for r in REQUIRES + [m]:
	    idl_include += '-I ' + path.join(r, 'idl') + ' '
	    include += '-I ' + path.join(BUILD, 'include', r) + ' '

	# clone the environment for each module so we can make REQUIRES do
	# its job
	e = env.Copy(
	    Builders = Builders,
	    INCLUDE = include,
	    IDL_INCLUDE = idl_include,
	    LIBRARIES = 'xpcom.lib user32.lib')

	# compile (type libraries)/(header files)
        for i in IDL_FILES:
            e.TypeLibrary(target = path.join(BUILD, 'bin', 'components', i + '.xpt'),
                          source = path.join(m, 'idl', i + '.idl'))
	    e.InterfaceHeader(target = path.join(BUILD, 'include', m, i + '.h'),
			      source = path.join(m, 'idl', i + '.idl'))

	# build module programs
	for i in PROGRAMS:
	    objects = []
	    for s in i['sources']:
		o = path.join(BUILD, 'obj', s + '.obj')
		e.Object(target = o,
		         source = path.join(m, 'src', s + '.cpp'))
		objects.append(o)

	    e.Program(target = path.join(BUILD, 'bin', i['target'] + '.exe'),
		      source = objects)

	# build module components
	for i in COMPONENTS:
	    objects = []
	    for s in i['sources']:
		srcdir = 'src'
		if i.has_key('srcdir'):
		    srcdir = i['srcdir']
		o = path.join(BUILD, 'obj', s + '.obj')
		e.Object(target = o,
			 source = path.join(m, srcdir, s + '.cpp'))
		objects.append(o)

	    e.Component(target = path.join(BUILD, 'bin', 'components', i['target'] + '.dll'),
			source = objects)

    except IOError:
        sys.stderr.write("Skipping module: %s\n" % m)
